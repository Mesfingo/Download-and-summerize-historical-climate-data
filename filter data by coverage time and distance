 # The function takes as an input a  climate data generated by the function ... in this repositery 
 # in the form of a list, along with additional information provided as part of  and and outputs a 
 #'tibble' dataframe with  data from stations with the given variable in the given time range and 
 # the closest distance to the location of interest. The function takes the following arguments
 
 #  1. srt = start date of desired coverage in the form of 'yyyy-mm-dd'
 #  2. end = end date of desired coverage in the form of 'yyyy-mm-dd'
 #  3. var = a character of length 1 giving the code name for the climate variable of interest
 #  4. dat = the list containing climate data generated by the function...
 #  5. dis_table = a dataframe with 3 columns ("locID", "id", "distance") describing the distance of 
 #                each wather station to the locations of interest
 
 
 ***************************************************************
 
 
 
 
 filter_var_coverage_distance <- function(str, end, var, dat, dis_table){
  
   # load/install important packages
   if(!suppressMessages(require("data.table", quietly = T))){
     install.packages("data.table")
     message("The package 'data.table' has been installed." )
   }
   
   if(!suppressMessages(require("pbapply", quietly = T))){
     install.packages("pbapply")
     message("The package 'pbapply' has been installed." )
   }

  station_with_var <- pbsapply(dat, function(i) var %in% names(i)) # subset by prescence of variable
  dat <- dat[station_with_var] # subset by prescence of variable
  
  with_coverage <- pbsapply(1:length(dat), function(i) { # get a logical for coverage time
      sta_time <- as.Date(dat[[i]][[var]]$date, tz = "GMT")
      st <- as.Date(str, tz = "GMT")
      en <- as.Date(end, tz = "GMT")
  
      sta_time <- sta_time[sta_time %between% c(st, en)]
      sta_time <- sta_time[order(as.Date(sta_time, tz = "GMT"))]
  
  
        if (length(sta_time) < 2) {
              return(FALSE)
          } 
         else 
            {
                  sta_time_begins <- as.Date(sta_time[1],  tz = "GMT")
                  sta_time_ends <- as.Date(sta_time[length(sta_time)], tz = "GMT")
            
                  exp_time_begins <- as.Date(st, tz = "GMT")
                  exp_time_ends <- as.Date(en, tz = "GMT")
  
                  sta_cov_length <- length(seq(from = sta_time_begins, 
                                               to = sta_time_ends, by='month')) - 1
                  exp_cov_length <- length(seq(from=exp_time_begins, 
                                               to = exp_time_ends, by='month')) - 1
                  
                  covers <- sta_cov_length >= exp_cov_length
                  return(covers)
            }
      })
  
  num_stations <- sum(with_coverage)
  if (num_stations == 0) {
          stop(paste("There are no stations with", var, 
                     "data within the time range", str, ":", end), quote = FALSE)
    }
  print(paste("There are ", num_stations, "stations with", var, 
              "data within the time range", str, ":", end),  quote = FALSE)
  
  
  dat <- dat[with_coverage] # subset by coverage time

  
  dat <- pblapply(dat,  `[[`, var) # keep only dataframes with the variable of interest
  
  is_empty <- pbsapply(dat, function(i) dim(i)[1] == 0) # get logical for empty tables
  dat <- dat[!is_empty] # remove stations with empty row
  
  sta_ids <- unique(sapply(1:length(dat), function(i){ # get station ids for filtered data
    ids <- as.character(dat[[i]][["id"]])
    ids <- ids[!is.na(ids)]
    if (length(unique(ids)) > 1) {
      warning(paste("Table", i, "has more than 1 stations IDs.
                    The most frequent ID will be used"))
      }
    names(sort(table(ids))[1]) # get the most frequent ID
    })) 
  

  # make a table with distance of each station from the location of interest
  if (!all(sta_ids %in% dis_table[, 1])){
    num_missing <- sum(!(sta_ids %in% dis_table[, 1]))
    pecnt_missing <- (num_missing/length(sta_ids))*100
    warning(paste(num_missing, "staions,",pecnt_missing, "%, 
    could not be found in the 'sta_dis' table provided"))
  }
  
  sta_dis <- merge(as.data.frame(sta_ids), dis_table, by.x = 1, by.y= 1, all.x = T)
  
  # identify the id with minimum distance for each location
  closest_sta <- lapply(unique(sta_dis$locID), function(i) {
    loc <- sta_dis[sta_dis$locID == i, ]
    loc[which.min(loc$distance), ] 
  })
  closest_sta <- as.data.frame(do.call(rbind, closest_sta))
  
  
  # subset weather data for the selected stations 
  is_closest <- sapply(dat, function(i){ # keep only the closest station
    any(i[[1]] %in% as.character(closest_sta[, 1]))
  })
  dat <- dat[is_closest]
  
  dat <- do.call(rbind, dat) # change data frame
  
  
  # add location ID and distance to location for each station
  dat$locID <- as.character(rep(NA, nrow(dat)))
  dat$distance <- rep(NA, nrow(dat))
  closest_sta$locID <- as.character(closest_sta$locID)
  
  for(i in unique(closest_sta$sta_ids)){
    dat[dat$id == i, 
              c("locID", "distance")] <- closest_sta[closest_sta$sta_ids == i, 
                                                     c("locID", "distance"), drop = F]
  }
  # print a message for the number of locations there is data for
  num_with_data <- length(unique(dat$locID))
  num_original <-  length(unique(dis_table$locID))
  print(paste("There is data for", 
              paste0(num_with_data, "/", num_original),
              "unique locations"), quote = F)
  
  return(dat)
}
